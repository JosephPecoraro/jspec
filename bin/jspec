#!/usr/bin/env ruby

JSPEC_ROOT = File.expand_path(File.join(File.dirname(__FILE__), '..'))
$:.unshift JSPEC_ROOT

require 'rubygems'
require 'commander'
require 'bind'
require 'fileutils'
require 'server/server'

program :name, 'JSpec'
program :version, '2.11.0'
program :description, 'JavaScript BDD Testing Framework'
default_command :bind

command :init do |c|
  c.syntax = 'jspec init [dest]'
  c.summary = 'Initialize a JSpec project template'
  c.description = 'Initialize a JSpec project template. Defaults to the current directory
    when [dest] is not specified. The template includes several files for 
    running via Rhino, DOM, and the JSpec Rack server.
    
    Additional switches --freeze, and --symlink are available in order
    to preserve the version of JSpec at the time of initialization. Otherwise
    incompatibilities from later versions may prevent your suite from
    running properly.'
  c.option '-R', '--rails', 'Initialize rails template from rails root directory'
  c.option '-f', '--freeze', 'Copy the JSpec library'
  c.option '-s', '--symlink', 'Symlink the JSpec library instead of copying it'
  c.example 'Create a directory foo, initialized with a jspec template', 'jspec init foo'
  c.when_called do |args, options|
    if options.rails
      JSpec::Project::Rails.new(args.first || '.').init! options.__hash__
    else
      JSpec::Project.new(args.first || '.').init! options.__hash__
    end
    say "Template initialized at `#{args.first}'"
  end
end

command :shell do |c|
  c.syntax = 'jspec shell [path ...]'
  c.summary = 'JSpec interactive shell'
  c.description = 'Launch interactive shell with jspec.js, jspec.shell.js, 
    and any [path]s given. Simply type "quit" or "exit" to 
    terminate the shell.'
  c.example 'Run shell', 'jspec shell'
  c.example 'Run shell with glob of files', 'jspec shell lib/*.js'
  c.example 'Run shell with list of files', 'jspec shell lib/foo.js lib/bar.js'
  c.when_called do |args, options|
    paths = ['jspec.js', 'jspec.shell.js'] | args
    paths.map! do |path|
      if path.include? 'jspec.'
        "-f #{JSPEC_ROOT}/lib/#{path}"
      else
        "-f #{path}"
      end
    end
    say "JSpec #{program(:version)}"
    `#{RHINO} #{paths.join(' ')} -f -`
  end
end

command :update do |c|
  c.syntax = 'jspec update [dest]'
  c.summary = 'Update JSpec releases'
  c.description = 'Update JSpec release relative to [dest], this will allow you to utilize 
    the latest JSpec features. Execute from JSpec project root without [dest] to
    update the default template spec files.'
  c.when_called do |args, options|
    JSpec::Project.new(args.first).update!
  end
end

command :run do |c|
  c.syntax = 'jspec run [path] [options]'
  c.summary = 'Run specifications'
  c.description = 'Run specifications, defaulting [path] to spec/environments/dom.html.
    You will need to supply [path] if your specs do not reside 
    in this location. `run --bind` is the default sub-command of
    jspec so you may simply execute `jspec` in order to bind execution
    of your specs when a file is altered.
    
    JSpec supports Rhino execution when installed. The [path] is assumed
    to be spec/environments/rhino.js unless specified. See examples below for
    using the --rhino switch.
    
    JSpec\'s server is also available via --server, which defaults 
    the [path] to spec/environments/server.html'
  c.example 'Run once in Safari', 'jspec run'
  c.example 'Run once in Safari and Firefox', 'jspec run --browsers Safari,Firefox'
  c.example 'Run once in Opera, Firefox, and Chrome', 'jspec run --browsers opera,ff,chrome'
  c.example 'Run custom spec file', 'jspec run foo.html'
  c.example 'Auto-run browsers when a file is altered', 'jspec run --bind --browsers Safari,Firefox'
  c.example 'Shortcut for the previous example', 'jspec --browsers Safari,Firefox'
  c.example 'Run Rhino specs', 'jspec run --rhino'
  c.example 'Auto-run rhino when a file is altered', 'jspec --rhino'
  c.option '-b', '--browsers BROWSERS', Array, 'Specify browsers to test'
  c.option '-p', '--paths PATHS', Array, 'Specify paths when binding, defaults to javascript within ./lib and ./spec'
  c.option '-B', '--bind', 'Auto-run specs when source files or specs are altered'
  c.option '-R', '--rhino', 'Run specs using Rhino'
  c.option '-S', '--server', 'Run specs using the JSpec server'
  c.option '-P', '--port NUMBER', Integer, 'Start JSpec server using the given port number'
  c.when_called do |args, options|
    base = options.rails ? JSpec::Project::Rails : JSpec::Project
    base.new('.').run! args.first, options.__hash__
  end
end
alias_command :bind, :run, '--bind'

module JSpec
  
  #--
  # Base project
  #++
  
  class Project
    
    #--
    # Constants
    #++
    
    BIND_PATHS = 'lib/**/*.js', 'spec/**/*.js'
    RHINO = 'java org.mozilla.javascript.tools.shell.Main'
    
    ##
    # Destination directory.
    
    attr_reader :dest
    
    ##
    # Initialize project with _dest_.
    
    def initialize dest
      @dest = dest || '.'
    end
    
    ##
    # Execute _file_ with Rhino.

    def rhino file
      system "#{RHINO} #{file}"
    end
    
    ##
    # Initialize the project with _options_

    def init! options = {}
      verify_empty!
      copy_template :default
      vendorize_with_symlink if options.include? :symlink
      vendorize_with_copy if options.include? :freeze
      replace_root
    end
    
    ##
    # Vendorize JSpec with symlink.
    
    def vendorize_with_symlink
      FileUtils.symlink "#{JSPEC_ROOT}/lib", normalize('lib'), :force => true
    end
    
    ##
    # Vendorize JSpec with copy.
    
    def vendorize_with_copy
      FileUtils.cp_r "#{JSPEC_ROOT}/lib", normalize('lib')
    end
    
    ##
    # Copy template _name_ to the destination.
    
    def copy_template name, options = {}
      FileUtils.mkdir_p dest
      FileUtils.cp_r path_to_template(name), options[:to] ?
        "#{dest}/#{options[:to]}" :
          dest
    end
    
    ##
    # Normalize _path_.
    
    def normalize path
      "#{dest}/spec/#{path}"
    end
    
    ##
    # Check if we are working with vendorized JSpec.
    
    def vendorized?
      File.exist? normalize(:lib)
    end
    
    ##
    # Replace absolute JSPEC_ROOT paths.
    
    def replace_root
      replace_root_in 'environments/dom.html', 'environments/rhino.js'
    end
    
    ##
    # Replace absolute JSPEC_ROOT _paths_.
    
    def replace_root_in *paths
      root = vendorized? ? '.' : JSPEC_ROOT
      paths.each do |path|
        contents = File.read(normalize(path)).gsub 'JSPEC_ROOT', root
        File.open(normalize(path), 'w') { |file| file.write contents }
      end
    end
    
    ##
    # Path to template _name_.
    
    def path_to_template name
      "#{JSPEC_ROOT}/templates/#{name}/."
    end
    
    ##
    # Verify that the current directory is empty, otherwise 
    # prompt for continuation.
    
    def verify_empty!
      unless Dir[dest + '/*'].empty?
        abort unless agree "`#{dest}' is not empty; continue? "
      end
    end
    
    ##
    # Update absolute paths.
    
    def update!
      ['environments/dom.html', 'environments/rhino.js'].each do |path|
        path = normalize path
        next unless File.exists? path
        contents = File.read(path).gsub /visionmedia-jspec-(\d+\.\d+\.\d+)/, "visionmedia-jspec-#{program(:version)}"
        if program(:version) == $1
          say "skipping #{path}; already #{$1}"
          next
        end
        File.open(path, 'r+'){ |file| file.write contents } 
        say "updated #{path}; #{$1} -> #{program(:version)}"
      end
    end
    
    ##
    # Start server with _path_ html and _options_.

    def start_server path, options = {}
      set :port, options[:port] || 4444
      set :server, 'Mongrel'
      enable :sessions
      disable :logging
      hook = File.expand_path normalize('environments/server.rb')
      load hook if File.exists? hook
      browsers = browsers_for(options[:browsers]) if options.include? :browsers
      JSpec::Server.new(path, options.port).start(browsers)
    end

    ##
    # Return array of browser instances for the given _names_.

    def browsers_for names
      names.map do |name|
        begin
          Browser.subclasses.find do |browser|
            browser.matches_name? name
          end.new
        rescue
          raise "Unsupported browser `#{name}'"
        end
      end
    end
    
    ##
    # Run _path_ with _options_.
    
    def run! path = nil, options = {}
      paths = options[:paths] || self.class::BIND_PATHS

      # Action
      
      case
      when options.include?(:rhino)
        path ||= normalize('environments/rhino.js')
        action = lambda { rhino path }
      when options.include?(:server)
        raise 'Cannot use --bind with --server' if options.include? :bind
        path ||= normalize('environments/server.html')
        action = lambda { start_server path, options }
      else
        path ||= normalize('environments/dom.html')
        browsers = browsers_for options[:browsers] || ['safari']
        action = lambda do
          browsers.each do |browser|
            browser.visit File.expand_path(path)
          end
        end
      end 
      
      # Bind action
      
      if options.include? :bind
        Bind::Listener.new(
          :paths => paths,
          :interval => 1,
          :actions => [action],
          :debug => $stdout).run!
      else
        action.call File.new(path)
      end
    end
    
    #--
    # Rails project
    #++
    
    class Rails < self
      
      #--
      # Constants
      #++
      
      BIND_PATHS = 'public/javascripts/**/*.js', 'jspec/**/*.js'
      
      ##
      # Initialize the project with _options_

      def init! options = {}
        verify_rails!
        copy_template :rails, :to => :jspec
        vendorize_with_symlink if options.include? :symlink
        vendorize_with_copy if options.include? :freeze
        replace_root
      end
      
      ##
      # Normalize _path_.

      def normalize path
        "#{dest}/jspec/#{path}"
      end
      
      ##
      # Verify that the current directory is rails, otherwise 
      # prompt for continuation.

      def verify_rails!
        unless rails?
          abort unless agree "`#{dest}' does not appear to be a rails app; continue? "
        end
      end
      
      ##
      # Check if the destination is the root of 
      # a rails application.
      
      def rails?
        File.directory? dest + '/vendor'
      end
      
    end
    
  end
end

