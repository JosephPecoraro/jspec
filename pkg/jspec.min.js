
var JSpec={version:'0.3.2',main:this,suites:{},stats:{specs:0,assertions:0,failures:0,passes:0},matchers:{eql:"==",be:"alias eql",equal:"===",be_greater_than:">",be_less_than:"<",be_at_least:">=",be_at_most:"<=",be_a:"actual.constructor == expected",be_an:"alias be_a",be_empty:"actual.length == 0",be_true:"actual == true",be_false:"actual == false",be_type:"typeof actual == expected",match:"typeof actual == 'string' ? actual.match(expected) : false",have_length:"actual.length == expected",respond_to:"typeof actual[expected] == 'function'",include:{match:function(expected,actual){if(actual.constructor==String)return actual.match(expected)
else return expected in actual}},throw_error:{match:function(expected,actual){try{actual()}
catch(e){return true}}}},defaultContext:{sandbox:function(name){var sandbox=document.createElement('div')
sandbox.setAttribute('class','jspec-sandbox')
document.body.appendChild(sandbox)
return sandbox}},Matcher:function(name,matcher,expected,actual,negate){var self=this
this.name=name,this.message='',this.passed=false
if(typeof matcher=='string'){if(matcher.match(/^alias (\w+)/))matcher=JSpec.matchers[matcher.match(/^alias (\w+)/)[1]]
if(matcher.length<4)body='actual '+matcher+' expected'
else body=matcher
matcher={match:function(expected,actual){return eval(body)}}}
function print(object){if(object==null)return''
else if(object.jquery)return object.selector.length==0?object.get(0):"'"+object.selector+"'"
else if(typeof object=='string')return"'"+object+"'"
else return object}
function generateMessage(){return'expected '+print(actual)+' to '+(negate?' not ':'')+name.replace(/_/g,' ')+' '+print(expected)}
function setMessage(){if(typeof matcher.message=='function')
self.message=matcher.message(expected,actual,negate)
else
self.message=generateMessage()}
function pass(){setMessage()
JSpec.stats.passes+=1
self.passed=true}
function fail(){setMessage()
JSpec.stats.failures+=1}
this.match=function(){expected=expected==null?null:expected.valueOf()
return matcher.match.call(JSpec,expected,actual.valueOf())}
this.passes=function(){this.result=this.match()
return negate?!this.result:this.result}
this.exec=function(){this.passes()?pass():fail()
return this}},DOMFormatter:function(results,options){var markup='',report=document.getElementById('jspec')
if(!report)throw'JSpec requires div#jspec to output its reports'
markup+='<div id="jspec-report"><div class="heading">'+'<span class="passes">Passes: <em>'+results.stats.passes+'</em></span> '+'<span class="failures">Failures: <em>'+results.stats.failures+'</em></span>'+'</div><div class="suites">'
results.each(results.suites,function(description,suite){if(suite.ran){markup+='<div class="suite"><h2>'+description+'</h2>'
results.each(suite.specs,function(spec){var assertionCount=' (<span class="assertion-count">'+spec.assertions.length+'</span>)'
if(spec.requiresImplementation()){markup+='<p class="requires-implementation">'+spec.description+'</p>'}
else if(spec.passed()){markup+='<p class="pass">'+spec.description+assertionCount+'</p>'}
else{markup+='<p class="fail">'+spec.description+assertionCount+' <em>'+spec.failure().message+'</em>'+'</p>'}})
markup+='</div>'}})
markup+='</div></div>'
report.innerHTML=markup},TerminalFormatter:function(results){},Suite:function(description){this.specs=[],this.hooks={},this.description=description,this.ran=false
this.addSpec=function(spec){this.specs.push(spec)
spec.suite=this}
this.hook=function(hook){if(body=this.hooks[hook])
JSpec.evalBody(body,"Error in hook '"+hook+"', suite '"+this.description+"'")}},Spec:function(description,body){this.body=body,this.description=description,this.assertions=[]
this.failure=function(){var failure
JSpec.each(this.assertions,function(assertion){if(!assertion.passed&&!failure)failure=assertion})
return failure}
this.passed=function(){return!this.failure()}
this.requiresImplementation=function(){return this.assertions.length==0}},match:function(actual,name,expected,negate){negate=negate||false
var matcher=new JSpec.Matcher(name,this.matchers[name],expected,actual,negate)
return matcher.passes()},each:function(object,callback){for(var key in object){if(typeof object[key]=='function')continue
if(callback.length==1)
callback.call(this,object[key])
else
callback.call(this,key,object[key])}
return this},addMatchers:function(matchers){this.each(matchers,function(name,body){this.addMatcher(name,body)})
return this},addMatcher:function(name,body){this._addMatcher(name,body,true)._addMatcher(name,body,false)},_addMatcher:function(name,body,negate){Object.prototype['should_'+(negate?'not_':'')+name]=function(other){var matcher=new JSpec.Matcher(name,body,other,this,negate)
if(JSpec.currentSpec){JSpec.currentSpec.assertions.push(matcher.exec())
return matcher.result}}
return this},evalBody:function(body,errorMessage){try{var runner=function(){eval(JSpec.preProcessBody(body))}
runner.call(this.context||this.defaultContext)}
catch(e){throw(errorMessage||'Error: ')+e}},preProcessBody:function(body){body=body.replace(/\.should_(\w+)(?: |$)(.*)$/gm,'.should_$1($2)')
return body},parse:function(input){var describing,specing,capturing
var token,describe,spec,capture,body=[]
var tokens=this.tokenize(input)
while(tokens.length){token=tokens.shift()
switch(token){case'end':if(describing)this.suites[describe]=this.suites[describe]||new JSpec.Suite(describe)
if(specing){var newSpec=new JSpec.Spec(spec,body.join(''))
this.suites[describe].addSpec(newSpec)
body=[],spec=specing=null}
else if(capturing){var body=body.join('')
if(describing)this.suites[describe].hooks[capture]=body
body=[],capturing=capture=null}
else if(describing){describing=describe=null}
break
case'before':case'after':case'before_each':case'after_each':capturing=true;break
case'describe':describing=true;break
case'it':specing=true;break
case'__END__':return this;break}
if(spec||capture){body.push(token)}
else{if(capturing)capture=token
if(/'.*?'/.test(token)){if(specing)spec=token.replace(/'/g,'')
else if(describing)describe=token.replace(/'/g,'')}}}
return this},tokenize:function(input){if(input.constructor==Array)return input
var regexp=/(?:__END__|end|before_each|after_each|before|after|it|describe|'.*?')(?= |\n|$)|\n|./gm
return input.match(regexp)},report:function(options){options=options||{}
this.formatter?new this.formatter(this,options):new JSpec.DOMFormatter(this,options)
return this},run:function(){this.each(this.suites,function(suite){this.runSuite(suite)})
return this},runSuite:function(suite){suite.ran=true
suite.hook('before')
this.each(suite.specs,function(spec){suite.hook('before_each')
this.currentSpec=spec
this.stats.specs+=1
this.evalBody(spec.body,"Error in spec '"+spec.description+"': ")
this.stats.assertions+=spec.assertions.length
suite.hook('after_each')})
suite.hook('after')
return this},eval:function(input){return this.parse(input)},load:function(file){if('XMLHttpRequest'in this.main){var request=new XMLHttpRequest
request.open('GET',file,false)
request.send(null)
if(request.readyState==4)
return request.responseText}
else if('load'in this.main){load(file)}
else{throw'Cannot load '+file}},exec:function(file){return this.eval(this.load(file))}}
JSpec.addMatchers(JSpec.matchers)